

# The first 400 bytes of the compiled Linux kernel code. Linux kernel code compiles into instructions and data,
# so the array contains instructions with some data here and there
linux_instructions = [
    0x6f, 0x00, 0xc0, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x50, 0x57, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x52, 0x49, 0x53, 0x43, 0x56, 0x00, 0x00, 0x00, 0x52, 0x53, 0x43, 0x05, 0x00, 0x00, 0x00, 0x00,
    0x17, 0x25, 0x00, 0x00, 0x13, 0x05, 0xc5, 0xc7, 0x73, 0x10, 0x55, 0x30, 0x73, 0x10, 0x00, 0x34,
    0x67, 0x80, 0x00, 0x00, 0x73, 0x00, 0x50, 0x10, 0x6f, 0xf0, 0xdf, 0xff, 0x73, 0x10, 0x40, 0x30,
    0x73, 0x10, 0x40, 0x34, 0x0f, 0x10, 0x00, 0x00, 0xef, 0x00, 0x80, 0x0a, 0x17, 0x05, 0x00, 0x00,
    0x13, 0x05, 0xc5, 0x01, 0x73, 0x10, 0x55, 0x30, 0x13, 0x05, 0xf0, 0xff, 0x73, 0x10, 0x05, 0x3b,
    0x13, 0x05, 0xf0, 0x01, 0x73, 0x10, 0x05, 0x3a, 0x73, 0x25, 0x40, 0xf1, 0x97, 0x11, 0x35, 0x00,
    0x93, 0x81, 0xc1, 0xfe, 0xb7, 0x62, 0x00, 0x00, 0x73, 0xb0, 0x02, 0x30, 0x97, 0x16, 0x35, 0x00,
    0x93, 0x86, 0x46, 0xf6, 0x17, 0x57, 0x37, 0x00, 0x13, 0x07, 0xc7, 0x6a, 0x63, 0xd8, 0xe6, 0x00,
    0x23, 0xa0, 0x06, 0x00, 0x93, 0x86, 0x46, 0x00, 0xe3, 0xcc, 0xe6, 0xfe, 0x13, 0x04, 0x05, 0x00,
    0x93, 0x84, 0x05, 0x00, 0x17, 0x16, 0x35, 0x00, 0x13, 0x06, 0x86, 0xfa, 0x23, 0x20, 0xa6, 0x00,
    0x17, 0xf2, 0x30, 0x00, 0x13, 0x02, 0x02, 0x27, 0x17, 0xe1, 0x30, 0x00, 0x13, 0x01, 0x81, 0xf2,
    0x13, 0x85, 0x04, 0x00, 0x97, 0x90, 0x17, 0x00, 0xe7, 0x80, 0xc0, 0xd3, 0xef, 0xf0, 0x5f, 0xf5,
    0x17, 0xf2, 0x30, 0x00, 0x13, 0x02, 0x02, 0x25, 0x17, 0xe1, 0x30, 0x00, 0x13, 0x01, 0x81, 0xf0,
    0x97, 0x80, 0x17, 0x00, 0xe7, 0x80, 0xc0, 0xee, 0x17, 0x53, 0x17, 0x00, 0x67, 0x00, 0xc3, 0x59,
    0x13, 0x01, 0x00, 0x00, 0x93, 0x01, 0x00, 0x00, 0x13, 0x02, 0x00, 0x00, 0x93, 0x02, 0x00, 0x00,
    0x13, 0x03, 0x00, 0x00, 0x93, 0x03, 0x00, 0x00, 0x13, 0x04, 0x00, 0x00, 0x93, 0x04, 0x00, 0x00,
    0x13, 0x06, 0x00, 0x00, 0x93, 0x06, 0x00, 0x00, 0x13, 0x07, 0x00, 0x00, 0x93, 0x07, 0x00, 0x00,
    0x13, 0x08, 0x00, 0x00, 0x93, 0x08, 0x00, 0x00, 0x13, 0x09, 0x00, 0x00, 0x93, 0x09, 0x00, 0x00,
    0x13, 0x0a, 0x00, 0x00, 0x93, 0x0a, 0x00, 0x00, 0x13, 0x0b, 0x00, 0x00, 0x93, 0x0b, 0x00, 0x00,
    0x13, 0x0c, 0x00, 0x00, 0x93, 0x0c, 0x00, 0x00, 0x13, 0x0d, 0x00, 0x00, 0x93, 0x0d, 0x00, 0x00,
    0x13, 0x0e, 0x00, 0x00, 0x93, 0x0e, 0x00, 0x00, 0x13, 0x0f, 0x00, 0x00, 0x93, 0x0f, 0x00, 0x00,
    0x73, 0x50, 0x00, 0x34, 0x67, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]


class Memory:
    def __init__(self, linux_image):

        Linux_bytes = bytearray(linux_image)
        RAM_bytes = bytearray([0] * (64*1024*1024 - len(Linux_bytes)))

        self.RAM = bytearray()

        # Beginning of RAM is filled with Linux
        self.RAM.extend(Linux_bytes)

        # The rest of RAM is just 64MB - sizeof(linux_image) of empty space
        self.RAM.extend(RAM_bytes)

    # Returns a value stored at specified address
    # WARNING:
    #   Currently RAM is not implemented at all. Only the Linux kernel code at 0x80000000 is accessible. Everything else
    #   just returns zero.
    def get_1_byte(self, address):
        if address >= 0x80000000:
            RAM_addr = address - 0x80000000
            return self.RAM[RAM_addr]

        return 0

    def write_1_byte(self, address, value):
        if address >= 0x80000000:
            RAM_addr = address - 0x80000000
            self.RAM[RAM_addr] = value
        else:
            print("[ERROR] RAM: trying to write to unimplemented address")
            quit()

    # Read 32bits/4bytes starting from specified address
    # RISC-V starts in little endian mode, therefor we need to read data as little endian order
    def get_4_bytes__little_endian(self, address):
        # When you read byte-by-byte you will get the same value in both little endian CPU (LE) and big endian CPU (BE)
        # But if you read more than a byte into a register, LE and BE CPUs will put individual bytes into different
        # places in the register. It is similar to how some cultures read from left-to-right and some from right-to-left
        # If we imagine that single byte contains only single digit then following 4-bytes in memory [1,2,3,4] are read
        # by one CPU as number "1234" while a CPU with opposite endianness will read the same 4 bytes as a number "4321"
        #
        # Same is for writing a register into memory. In case of 32-bit (4 byte) register, LE and BE CPUs will
        # put individual bytes of register into different places in memory.
        # https://en.wikipedia.org/wiki/Endianness#Overview
        byte0 = self.get_1_byte(address)
        byte1 = self.get_1_byte(address + 1)
        byte2 = self.get_1_byte(address + 2)
        byte3 = self.get_1_byte(address + 3)

        value = (byte3 << 24) + (byte2 << 16) + (byte1 << 8) + byte0

        return value


if __name__ == '__main__':
    print(f"\nExecuting:\n\t{__file__} \n")
    print("Hopefully here we will have tests for functions in this file")
